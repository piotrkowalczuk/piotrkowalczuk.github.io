<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on Piotr Kowalczuk Blog</title>
    <link>http://piotrkowalczuk.github.io/post/</link>
    <description>Recent content in Posts on Piotr Kowalczuk Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>pl</language>
    <copyright>Piotr Kowalczuk</copyright>
    <lastBuildDate>Sat, 21 Oct 2017 19:56:18 +0200</lastBuildDate>
    <atom:link href="http://piotrkowalczuk.github.io/post/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>W Poszukiwaniu Pracy</title>
      <link>http://piotrkowalczuk.github.io/2017/10/21/w-poszukiwaniu-pracy/</link>
      <pubDate>Sat, 21 Oct 2017 19:56:18 +0200</pubDate>
      
      <guid>http://piotrkowalczuk.github.io/2017/10/21/w-poszukiwaniu-pracy/</guid>
      <description>

&lt;h2 id=&#34;wstęp:1ee101fad5fbad352ad8ecdf4216a0b4&#34;&gt;Wstęp&lt;/h2&gt;

&lt;p&gt;Pierwsza stabilna wersja języka została wydana w marcu 2012 roku.
Od tamtego czasu mineło już ponad 5 lat.&lt;/p&gt;

&lt;p&gt;W tym czasie w rankingu &lt;a href=&#34;https://www.tiobe.com/tiobe-index/&#34;&gt;TIOBE&lt;/a&gt; język Go zanotował wzrost z 0.086% do 1.357% i plasuje się na pozycji 20.
Mogłoby się to wydawać niewiele, ale jak porównamy to do Javascript&amp;rsquo;u posiadającego obecnie 3% udziału w rynku i będącego na pozycji 6, perspektywa trochę się zmienia.&lt;/p&gt;

&lt;p&gt;Język zajmuję też 9 miejsce pod względem ilości otwartych pull requestów na &lt;a href=&#34;https://octoverse.github.com&#34;&gt;githubie&lt;/a&gt;, posiadając 285 tysięcy kontrybucji.
Dla porównania - Java, znajdująca się na miejscu drugim, posiada ich 986 tysięcy.&lt;/p&gt;

&lt;p&gt;Szacuje się, że na tą chwilę na świecie jest przynajmniej &lt;a href=&#34;https://research.swtch.com/gophercount&#34;&gt;500 tysięcy&lt;/a&gt; developerów Go.
Język otrzymał wsparcie większości edytorów oraz środowisk deweloperskich.
Na etapie Early Access jest &lt;a href=&#34;https://www.jetbrains.com/go/&#34;&gt;komercyjne IDE&lt;/a&gt; od Jetbrains.
Golang jest także preinstalowany w wielu dystrybucjach linuxa.&lt;/p&gt;

&lt;p&gt;Dlaczego o tym wszystkim piszę?
Odnoszę wrażenie, że pomimo tych wszystkich lat Golang jest postrzegany jako coś egzotycznego i niszowego.
Przekłada się to bezpośrednio na podejscie kandydatów do procesu rekrutacji -
świadomość kandydata stoi w miejscu, a oczekiwania coraz bardziej doświadczonych zespołów rosną.&lt;/p&gt;

&lt;p&gt;Tym wpisem chciałbym wpłynąć na świadomość programistów w zakresie wymagań jakie są przed nimi stawiane. Lista poniżej jest moim &lt;strong&gt;subiektywnym&lt;/strong&gt; zestawieniem zagadnień, których znajomość w moich oczach pozytywnie wpływa na ocene kandydata.&lt;/p&gt;

&lt;h2 id=&#34;filozofia:1ee101fad5fbad352ad8ecdf4216a0b4&#34;&gt;Filozofia&lt;/h2&gt;

&lt;p&gt;Go nie bez powodu uchodzi za język prosty do nauki. W mojej ocenie jest to także jezyk zaskakująco trudny do opanowania.&lt;/p&gt;

&lt;p&gt;Trywialnym jest napisanie bylejakiego kodu. Trochę trudniejsze ale ciągle łatwe jest napisanie kodu przekombinowanego, z masą niepotrzebnej abstrakcji i komponentów. Napisanie kodu, który jest genialny w swojej prostocie jest naprawde trudne.&lt;/p&gt;

&lt;p&gt;Z moich obserwacji wynika, że czas potrzebny programistom na oduczenie się nawyków przyniesionych z wcześniejszych technologi jest nieakceptowanie długi.
Co do zasady sądze że powinno odrzucać się kandydatów, którzy nie pojeli filozofii Go w poziomie wystarczającym. Jest to zwyczajnie zbyt kosztowne i niebezpieczne dla kultury wytworzeonej w zespole.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.youtube.com/watch?v=rFejpH_tAHM&#34;&gt;Simplicity is Complicated&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://go-proverbs.github.io&#34;&gt;Proverbs&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;narzędzia:1ee101fad5fbad352ad8ecdf4216a0b4&#34;&gt;Narzędzia&lt;/h2&gt;

&lt;p&gt;Jednym z największych atutów Go jest jego środowisko developerskie. Poza językiem instalator instaluje również szereg narzędzi, powiedziałbym niezbędnych w codziennej pracy takich jak &lt;code&gt;cover&lt;/code&gt;, &lt;code&gt;fmt&lt;/code&gt;, &lt;code&gt;vet&lt;/code&gt;, &lt;code&gt;trace&lt;/code&gt; czy &lt;code&gt;pprof&lt;/code&gt;.
Znajomość tych narzędzi może być przydatna w trakcie rozmowy kwalifikacyjnej podczas sesji pair-programing, kiedy developer poprosi was o optymalizację albo naprawienie danej aplikacji.&lt;/p&gt;

&lt;p&gt;Ponadto, przydać się może doświadczenie z bardziej zaawansowanymi opcjami kompilacji. Dla przykładu kiedy chcemy przeprowadzić &lt;a href=&#34;https://en.wikipedia.org/wiki/Escape_analysis&#34;&gt;Escape Analysis&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&#34;współdzielenie-danych-i-synchronizacja:1ee101fad5fbad352ad8ecdf4216a0b4&#34;&gt;Współdzielenie danych i synchronizacja&lt;/h2&gt;

&lt;p&gt;Kanały są jednym z najbardziej rozpoznawalnych aspektów Go. Ich poprawne stosowanie przysparza kandydatom jednak wiele problemu. To zły znak. Przejawia się to najczęściej zbyt dużą ich ilością, dodatkowo niepotrzebnie użytą strukturą &lt;code&gt;sync.WaitGroup&lt;/code&gt; czy poprostu stosowaniem ich tam, gdzie jest to zbędne.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Share memory by communicating; don&amp;rsquo;t communicate by sharing memory&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Potencjalny kandydat musi rozumieć kiedy stosować kanały, &lt;a href=&#34;https://pl.wikipedia.org/wiki/Problem_wzajemnego_wykluczania&#34;&gt;mutex&lt;/a&gt; czy też może sprzętową synchronizację dostępną w paczce &lt;a href=&#34;https://golang.org/pkg/sync/atomic/&#34;&gt;sync/atomic&lt;/a&gt;.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://greenteapress.com/wp/semaphores/&#34;&gt;The Little Book of Semaphores&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://sigops.org/sosp/sosp13/papers/p33-david.pdf&#34;&gt;Everything You Always Wanted to Know About Synchronization but Were Afraid to Ask&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.golang.org/pipelines&#34;&gt;Go Concurrency Patterns: Pipelines and cancellation&lt;/a&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;przerwania:1ee101fad5fbad352ad8ecdf4216a0b4&#34;&gt;Przerwania&lt;/h2&gt;

&lt;p&gt;We wszelkiego rodzaju aplikacjach webowych czy też systemach rozproszonych, możliwość przerwania przetwarzania żądania jest na wagę złota. Taki mechanizm pozwala kontrolować zużycie zasobów (ich zwalnianie) oraz przestrzec się przed katastrofalnym w skutkach efektem domina.&lt;/p&gt;

&lt;p&gt;Znajomość paczki &lt;a href=&#34;https://golang.org/pkg/context&#34;&gt;context&lt;/a&gt; jest tutaj kluczowa.
Za jej pomocą jesteśmy w stanie anulować żądania oraz procesy, a także określać górną granice czasu, w którym nasza logika ma zostać wykonana.&lt;/p&gt;

&lt;p&gt;Temat zdecydowanie zasługuje na osobny wpis.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.golang.org/context&#34;&gt;Go Concurrency Patterns: Context&lt;/a&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;whitebox-monitoring-tracing:1ee101fad5fbad352ad8ecdf4216a0b4&#34;&gt;Whitebox Monitoring/Tracing&lt;/h2&gt;

&lt;p&gt;Ostatecznie nasz kod ląduje na produkcji. Rolą dewelopera jest udostępnienie metryk, które pomogą określić wydajność aplikacji oraz zweryfikować jej poprawne działanie.&lt;/p&gt;

&lt;p&gt;Do monitorowania najczęstszym wyborem, w przypadku zespołów, czysto Golangowych jest &lt;a href=&#34;https://prometheus.io&#34;&gt;Prometheus&lt;/a&gt;. Najpewniej żadne zadanie testowe nie będzie wymagać jego zastosowania, ale znajomość zagadnienia jest jak najbardziej na plus.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Tracing_(software)&#34;&gt;Tracing&lt;/a&gt; może zostać zaimplementowany na wiele sposobów. Na początek, znajomość paczki &lt;a href=&#34;https://godoc.org/golang.org/x/net/trace&#34;&gt;x/net/trace&lt;/a&gt; powinna wystarczyć.&lt;/p&gt;

&lt;h2 id=&#34;podsumowanie:1ee101fad5fbad352ad8ecdf4216a0b4&#34;&gt;Podsumowanie&lt;/h2&gt;

&lt;p&gt;Mimo iż Go jest stosowane przewarznie w zastosowaniach serwerowych/cloudowych, nie musi to być zasadą. Dlatego jeszcze raz chciałbym podkreślić, że reprezentuję tutaj jedynie mój prywatny punkt widzenia.&lt;/p&gt;

&lt;p&gt;Wiele tematów takich jak testowanie, benchmnarking czy stosowanie paczki &lt;code&gt;http&lt;/code&gt; umyślnie zignorowałem. Skupiłem się jedynie na aspektach, które najczęsciej są  pomijane przez kandydatów, których miałem przyjemność ewaluować.&lt;/p&gt;

&lt;p&gt;Mam nadzieję, że powyższy tekst pomoże komuś w znalezieniu upragnionej pracy. Wszystkim przyszłym &lt;a href=&#34;https://blog.golang.org/gopher&#34;&gt;gopherom&lt;/a&gt; życzę powodzenia.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Kolejka Priorytetowa</title>
      <link>http://piotrkowalczuk.github.io/2016/07/10/kolejka-priorytetowa/</link>
      <pubDate>Sun, 10 Jul 2016 20:12:00 +0200</pubDate>
      
      <guid>http://piotrkowalczuk.github.io/2016/07/10/kolejka-priorytetowa/</guid>
      <description>

&lt;h2 id=&#34;wstęp:042cb00d946fbfbaf0b1b50f0ee94629&#34;&gt;Wstęp&lt;/h2&gt;

&lt;p&gt;Kolejka priorytetowa to abstrakcyjna struktura danych gdzie elementy są uszeregowane według danej wielkości.
Kolejka ta nie jest kolejką typu FIFO czy też LIFO.
Ponieważ jest to &lt;a href=&#34;https://pl.wikipedia.org/wiki/Abstrakcyjny_typ_danych&#34;&gt;ADT&lt;/a&gt; może być ona zaimplementowana na wielę sposobów:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Kopiec binarny&lt;/li&gt;
&lt;li&gt;Kopiec dwumianowy&lt;/li&gt;
&lt;li&gt;Tablica&lt;/li&gt;
&lt;li&gt;Lista&lt;/li&gt;
&lt;li&gt;Rownoważone BST&lt;/li&gt;
&lt;li&gt;Kopiec Fibonacciego&lt;/li&gt;
&lt;li&gt;Kolejka Brodala&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;zagadnienie:042cb00d946fbfbaf0b1b50f0ee94629&#34;&gt;Zagadnienie&lt;/h2&gt;

&lt;p&gt;Aby nadać problemowi bardziej intuicyjny charakter spróbujmy zastosować go w praktyce.
Naszym zadaniem będzie utworzenie kolejki poleceń. Zadania mogą być dodawane w dowolnej kolejności.
Każde polecenie powinno być opisane przez:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;id&lt;/code&gt; - identyfikator&lt;/li&gt;
&lt;li&gt;&lt;code&gt;index&lt;/code&gt; - miejsce w kolejce&lt;/li&gt;
&lt;li&gt;&lt;code&gt;name&lt;/code&gt; - nazwa&lt;/li&gt;
&lt;li&gt;&lt;code&gt;timestamp&lt;/code&gt; - data do kiedy zadanie powinno zostać wykonane&lt;/li&gt;
&lt;li&gt;&lt;code&gt;epsilon&lt;/code&gt; - czas po wyznaczonej dacie wykonania po upłynięciu którego zadanie powinno zostać porzucone&lt;/li&gt;
&lt;li&gt;&lt;code&gt;command&lt;/code&gt; - komenda uruchamiająca skrypt/program&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;propozycja-rozwiązania:042cb00d946fbfbaf0b1b50f0ee94629&#34;&gt;Propozycja rozwiązania&lt;/h3&gt;

&lt;p&gt;Biblioteka standardowa Go jest naprawdę bogata.
Nie zabrakło także implementacji stosu (binarnego).
Paczka &lt;a href=&#34;https://golang.org/pkg/container/heap/&#34;&gt;heap&lt;/a&gt;, bo o niej tutaj mowa dostarcza nam taki oto interface:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type Interface interface {
	sort.Interface
	Push(x interface{})
	Pop() interface{}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Który jeżeli zaimplementowany poprawnie może być wykorzystany przy użyciu szeregu funkcji:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://golang.org/pkg/container/heap/#Init&#34;&gt;heap.Init&lt;/a&gt; - inicjalizacja stosu, &lt;code&gt;O(n)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://golang.org/pkg/container/heap/#Push&#34;&gt;heap.Push&lt;/a&gt; - dodanie elementu, &lt;code&gt;O(log(n))&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://golang.org/pkg/container/heap/#Pop&#34;&gt;heap.Pop&lt;/a&gt; - usuniecie elementu minimalnego, &lt;code&gt;O(log(n))&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://golang.org/pkg/container/heap/#Remove&#34;&gt;heap.Remove&lt;/a&gt; - usuniecie elementy pod podanym indexem, &lt;code&gt;O(log(n))&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://golang.org/pkg/container/heap/#Fix&#34;&gt;heap.Fix&lt;/a&gt; - &amp;ldquo;naprawienie&amp;rdquo; stosu po np zmianie wartosci jednego z elementow, &lt;code&gt;O(log(n))&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;implementacja:042cb00d946fbfbaf0b1b50f0ee94629&#34;&gt;Implementacja&lt;/h3&gt;

&lt;p&gt;Raz jeszcze skorzystamy z dobrodziejstw biblioteki standardowej.
Znaleźć w niej możemy paczkę &lt;a href=&#34;https://golang.org/pkg/os/exec/&#34;&gt;exec&lt;/a&gt; w której to znajduje się struktura &lt;a href=&#34;https://golang.org/pkg/os/exec/#Cmd&#34;&gt;exec.Cmd&lt;/a&gt;.
Struktura reporezentująca pojedyńcze polecenie do wykonania mogłaby wyglądać następująco:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type Job struct {
	ID int64
	Index int64
	Name string
	Timestamp time.Time
	Epsilon time.Duration
	Command *exec.Cmd
}

type Jobs []*Job
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Kolekcja takich struktur musi implementować wcześniej wymieniony &lt;a href=&#34;https://golang.org/pkg/container/heap/#Interface&#34;&gt;Interface&lt;/a&gt;.
A więc po kolei:&lt;/p&gt;

&lt;h4 id=&#34;len:042cb00d946fbfbaf0b1b50f0ee94629&#34;&gt;Len&lt;/h4&gt;

&lt;p&gt;Jak sama nazwa wskazuje sprawdza długość kolekcji.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Len implements sort Interface.
func (j Jobs) Len() int {
	return len(j)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;less:042cb00d946fbfbaf0b1b50f0ee94629&#34;&gt;Less&lt;/h4&gt;

&lt;p&gt;Metoda ta nie tylko sprawdza który deadline nastąpi jako pierwszy,
ale w wypadku gdy są równe, porównuje także wartość &lt;code&gt;Epsilon&lt;/code&gt;.
Jest to jedynie przykładowa implementacja.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Less implements sort Interface.
func (j Jobs) Less(n, m int) bool {
	if j[n].Timestamp.Equal(j[m].Timestamp) {
		return j[n].Epsilon &amp;lt; j[m].Epsilon
	}
	return j[n].Timestamp.Before(j[m].Timestamp)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;swap:042cb00d946fbfbaf0b1b50f0ee94629&#34;&gt;Swap&lt;/h4&gt;

&lt;p&gt;Nic innego jak zamiana elementów pod wskazanymi indeksami.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Swap implements sort Interface.
func (j Jobs) Swap(n, m int) {
	j[n], j[m] = j[m], j[n]
	j[n].Index = int64(n)
	j[m].Index = int64(m)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;push:042cb00d946fbfbaf0b1b50f0ee94629&#34;&gt;Push&lt;/h4&gt;

&lt;p&gt;Przez push rozumiemy dodanie na koniec kolekcji nowego elementu i ustawienie jego indeksu na &lt;code&gt;n&lt;/code&gt;.
Funkcja &lt;a href=&#34;https://golang.org/pkg/container/heap/#Push&#34;&gt;heap.Push&lt;/a&gt; użyje tej metody na początku, a następnie będzie przesuwać element do góry tak długo jak to tylko możliwe, aż osiągnie właściwy dla siebie index wynikający z warunku zawartego w metodzie &lt;code&gt;Less&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Push implements heap Interface.
func (j *Jobs) Push(x interface{}) {
	n := len(*j)
	item := x.(*Job)
	item.Index = int64(n)
	*j = append(*j, item)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;pop:042cb00d946fbfbaf0b1b50f0ee94629&#34;&gt;Pop&lt;/h4&gt;

&lt;p&gt;Usuniecie zadania z kolejki odbywa się przez utworzenie nowego &lt;a href=&#34;https://blog.golang.org/go-slices-usage-and-internals&#34;&gt;slice&amp;rsquo;a&lt;/a&gt; z pominięciem ostatniego elementu.
Dla jasności ustawiamy także &lt;code&gt;Index&lt;/code&gt; usuniętego elementu na &lt;code&gt;-1&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Pop implements heap Interface.
func (j *Jobs) Pop() interface{} {
	old := *j
	n := len(old)
	item := old[n-1]
	item.Index = -1
	*j = old[0 : n-1]
	return item
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;efekt-końcowy:042cb00d946fbfbaf0b1b50f0ee94629&#34;&gt;Efekt końcowy&lt;/h4&gt;

&lt;p&gt;Całość działa tak jak przewiduje to koncepcja kolejki priorytetowej.
&lt;a href=&#34;https://blog.golang.org/examples&#34;&gt;Testowy przykład&lt;/a&gt; to potwierdza.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func ExampleJobs() {
	jobs := make(Jobs, 0, 3)
	zero := time.Now()
	heap.Init(&amp;amp;jobs)
	heap.Push(&amp;amp;jobs, &amp;amp;Job{
		ID:        1,
		Name:      &amp;quot;first&amp;quot;,
		Timestamp: zero.Add(10 * time.Hour),
		Epsilon:   5 * time.Minute,
		Command:   exec.Command(&amp;quot;ls&amp;quot;, &amp;quot;-lha&amp;quot;),
	})
	heap.Push(&amp;amp;jobs, &amp;amp;Job{
		ID:        1,
		Name:      &amp;quot;second&amp;quot;,
		Timestamp: zero.Add(10 * time.Hour),
		Epsilon:   4 * time.Minute,
		Command:   exec.Command(&amp;quot;pwd&amp;quot;),
	})
	heap.Push(&amp;amp;jobs, &amp;amp;Job{
		ID:        1,
		Name:      &amp;quot;third&amp;quot;,
		Timestamp: zero.Add(5 * time.Hour),
		Epsilon:   4 * time.Minute,
		Command:   exec.Command(&amp;quot;ps&amp;quot;, &amp;quot;aux&amp;quot;),
	})
	fmt.Println(jobs.Len())

	j1 := heap.Pop(&amp;amp;jobs).(*Job)
	j2 := heap.Pop(&amp;amp;jobs).(*Job)
	j3 := heap.Pop(&amp;amp;jobs).(*Job)

	fmt.Println(j1.Name)
	fmt.Println(j2.Name)
	fmt.Println(j3.Name)
	fmt.Println(jobs.Len())

	// Output:
	// 3
	// third
	// second
	// first
	// 0
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;wnioski:042cb00d946fbfbaf0b1b50f0ee94629&#34;&gt;Wnioski&lt;/h2&gt;

&lt;p&gt;Kolejka priorytetowa to bardzo ważna struktura danych szczególnie w przypadku wszelkiego rodzaju aplikacji serwerowych.
Przed przystąpieniem do rozwiazania problemu warto przyjrzeć się &lt;a href=&#34;https://golang.org/pkg/&#34;&gt;bibliotece standardowej&lt;/a&gt;,
może zawierać ona przydatne interfacy/implementacje czy także &lt;a href=&#34;https://golang.org/pkg/container/heap/#example__priorityQueue&#34;&gt;przykłady&lt;/a&gt;:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://golang.org/pkg/container/heap&#34;&gt;container/heap&lt;/a&gt; - implementacja stosu&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://golang.org/pkg/container/list&#34;&gt;container/list&lt;/a&gt; - implementacja podwujnie łączonej listy&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://golang.org/pkg/container/ring&#34;&gt;container/ring&lt;/a&gt; - operacje na listach cyklicznych&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
  </channel>
</rss>