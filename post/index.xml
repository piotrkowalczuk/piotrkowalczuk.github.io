<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on Piotr Kowalczuk Blog</title>
    <link>https://piotrkowalczuk.github.io/post/</link>
    <description>Recent content in Posts on Piotr Kowalczuk Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>pl</language>
    <copyright>Piotr Kowalczuk</copyright>
    <lastBuildDate>Tue, 14 Nov 2017 00:12:21 +0100</lastBuildDate>
    <atom:link href="https://piotrkowalczuk.github.io/post/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Prometheus</title>
      <link>https://piotrkowalczuk.github.io/2017/11/14/prometheus-monitorowanie-serwera-http/</link>
      <pubDate>Tue, 14 Nov 2017 00:12:21 +0100</pubDate>
      
      <guid>https://piotrkowalczuk.github.io/2017/11/14/prometheus-monitorowanie-serwera-http/</guid>
      <description>

&lt;h2 id=&#34;czym-jest-prometheus:344187460f15e6ef8677e80bc40cccdc&#34;&gt;Czym jest Prometheus?&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://prometheus.io&#34;&gt;Prometheus&lt;/a&gt; jest to ekosystem do monitorowania napisany przez programistów z &lt;a href=&#34;https://soundcloud.com&#34;&gt;SoundCloud&lt;/a&gt;.
Jak możecie się przekonać przeglądając oficjalne konto na &lt;a href=&#34;https://github.com/prometheus&#34;&gt;githubie&lt;/a&gt;, większość środowiska jest napisana w &lt;a href=&#34;http://golang.org&#34;&gt;Go&lt;/a&gt;.
Od 2016 roku projekt jest też częścią &lt;a href=&#34;https://www.cncf.io&#34;&gt;Cloud Native Computing Foundation&lt;/a&gt; obok takich rozwiązań jak &lt;a href=&#34;https://kubernetes.io&#34;&gt;kubernetes&lt;/a&gt;, &lt;a href=&#34;http://grpc.io&#34;&gt;gRPC&lt;/a&gt; czy &lt;a href=&#34;http://opentracing.io&#34;&gt;OpenTracing&lt;/a&gt;.
Daje nam to pewność, że projekt będzie rozwijany przez długie lata, będzie ewoluował razem z resztą środowiska, a także wsparcie dla &lt;strong&gt;Go&lt;/strong&gt; będzie stało na najwyższym poziomie.&lt;/p&gt;

&lt;p&gt;Skupię się tutaj na ostatniej wersji, oznaczonej tagiem &lt;code&gt;v0.8.0&lt;/code&gt;.
W tej wersji wiele funkcji zostało oznaczonych jako &lt;code&gt;DEPRECATED&lt;/code&gt; i zostaną one przeze mnie pominięte.
Zalecana wersja Go to 1.9+.&lt;/p&gt;

&lt;h2 id=&#34;biblioteka:344187460f15e6ef8677e80bc40cccdc&#34;&gt;Biblioteka&lt;/h2&gt;

&lt;p&gt;Zasadniczo &lt;strong&gt;Prometheus&lt;/strong&gt; jako serwer centralny musi być świadomy istnienia aplikacji która jest monitorowana.
Tylko wtedy jest on w stanie pobrać metryki ze wskazanego endpointu.
Z pomocą przychodzi nam biblioteka &lt;a href=&#34;https://godoc.org/github.com/prometheus/client_golang/prometheus/promhttp&#34;&gt;promhttp&lt;/a&gt;, która jest częścią składową oficjalnej &lt;a href=&#34;https://github.com/prometheus/client_golang/tree/master/prometheus&#34;&gt;paczki&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://godoc.org/github.com/prometheus/client_golang/prometheus/promhttp#HandlerFor&#34;&gt;promhttp.HandlerFor&lt;/a&gt; pozwala utworzyć endpoint dla danego &lt;a href=&#34;https://godoc.org/github.com/prometheus/client_golang/prometheus#Gatherer&#34;&gt;prometheus.Gatherer&amp;rsquo;a&lt;/a&gt;.
Interfejs ten jest na przykład implementowany przez &lt;a href=&#34;https://godoc.org/github.com/prometheus/client_golang/prometheus#pkg-variables&#34;&gt;prometheus.DefaultRegisterer&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Ponadto biblioteka ta zawiera garść dekoratorów które, pozwolą nam zbierać informacje na temat naszej aplikacji:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://godoc.org/github.com/prometheus/client_golang/prometheus/promhttp#InstrumentHandlerCounter&#34;&gt;promhttp.InstrumentHandlerCounter&lt;/a&gt; - całkowita liczba przetworzonych żądań&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://godoc.org/github.com/prometheus/client_golang/prometheus/promhttp#InstrumentHandlerDuration&#34;&gt;promhttp.InstrumentHandlerDuration&lt;/a&gt; - czas trwania żądania&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://godoc.org/github.com/prometheus/client_golang/prometheus/promhttp#InstrumentHandlerTimeToWriteHeader&#34;&gt;promhttp.InstrumentHandlerTimeToWriteHeader&lt;/a&gt; - podobnie jak poprzedni tylko do czasu wysłania nagłówków&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://godoc.org/github.com/prometheus/client_golang/prometheus/promhttp#InstrumentHandlerInFlight&#34;&gt;promhttp.InstrumentHandlerInFlight&lt;/a&gt; - liczba obecnie przetwarzanych żądań (w trakcie)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://godoc.org/github.com/prometheus/client_golang/prometheus/promhttp#InstrumentHandlerRequestSize&#34;&gt;promhttp.InstrumentHandlerRequestSize&lt;/a&gt; - wielkość żądania&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;implementacja:344187460f15e6ef8677e80bc40cccdc&#34;&gt;Implementacja&lt;/h2&gt;

&lt;p&gt;Jak widać, żeby zacząć nie trzeba się wiele napracować. Większość potrzebnych nam składników jest już dostępna.
Brakujący element to &lt;a href=&#34;https://godoc.org/github.com/prometheus/client_golang/prometheus#Collector&#34;&gt;kolektory&lt;/a&gt; które musimy zainicjować własnoręcznie.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;duration := prometheus.NewHistogramVec(
    prometheus.HistogramOpts{
        Namespace: &amp;quot;acme&amp;quot;,
        Subsystem: &amp;quot;your_app&amp;quot;,
        Name:      &amp;quot;http_durations_histogram_seconds&amp;quot;,
        Help:      &amp;quot;Request time duration.&amp;quot;,
    },
    []string{&amp;quot;code&amp;quot;, &amp;quot;method&amp;quot;},
)
requests := prometheus.NewCounterVec(
    prometheus.CounterOpts{
        Namespace: &amp;quot;acme&amp;quot;,
        Subsystem: &amp;quot;your_app&amp;quot;,
        Name:      &amp;quot;http_requests_total&amp;quot;,
        Help:      &amp;quot;Total number of requests received.&amp;quot;,
    },
    []string{&amp;quot;code&amp;quot;, &amp;quot;method&amp;quot;},
)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Oba one muszą zostać zarejestrowane, a następnie przekazane jako argument do wyżej wymienionych dekoratorów.
Możemy trochę usprawnić ten proces poprzez wprowadzenie dodatkowej struktury.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type decorator struct {
	duration *prometheus.HistogramVec
	requests *prometheus.CounterVec
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Aby spełniać swoje zadanie, struktóra ta powinna implementować interfejs &lt;a href=&#34;https://godoc.org/github.com/prometheus/client_golang/prometheus#Collector&#34;&gt;prometheus.Collector&lt;/a&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Describe implements prometheus Collector interface.
func (d *decorator) Describe(in chan&amp;lt;- *prometheus.Desc) {
	d.duration.Describe(in)
	d.requests.Describe(in)
}

// Collect implements prometheus Collector interface.
func (d *decorator) Collect(in chan&amp;lt;- prometheus.Metric) {
	d.duration.Collect(in)
	d.requests.Collect(in)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Dodatkowo, możemy zredukować duplikację kodu implementując dodatkową metodę.
Jej zadaniem będzie dekorowanie danego handlera szeregiem funkcji.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func (d *decorator) instrument(handler http.Handler) http.Handler {
	return promhttp.InstrumentHandlerDuration(
		d.duration,
		promhttp.InstrumentHandlerCounter(
			d.requests,
			handler,
		),
	)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Naszym ostatnim krokiem będzie połączenie wszystkiego ze sobą i udostępnienie metryk.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func main() {
    dec := &amp;amp;decorator{
        // inicjalizacja
    }

    prometheus.DefaultRegisterer.Register(dec)

    go func() {
        dbg := http.NewServeMux()
        dbg.Handle(&amp;quot;/metrics&amp;quot;, promhttp.HandlerFor(
            prometheus.DefaultGatherer,
            promhttp.HandlerOpts{},
        ))
        http.ListenAndServe(&amp;quot;0.0.0.0:8081&amp;quot;, dbg)
    }()

    app := http.NewServeMux()
    app.Handle(&amp;quot;/&amp;quot;, dec.instrument(&amp;amp;handler{}))
    http.ListenAndServe(&amp;quot;0.0.0.0:8080&amp;quot;, app)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Aplikacja przez nas napisana będzie nasłuchiwać na dwóch portach.
Pierwszy &lt;code&gt;8080&lt;/code&gt;, zarezerowany dla aplikacji właściwej.
Drugi &lt;code&gt;8081&lt;/code&gt;, na którym prometheus będzie miał dostęp do metryk.
Chciałbym zwrócić uwagę, że router został w drugim przypadku zastosowany nie bez powodu.
Pozwoli on w przyszłości udostępnić na tym samym porcie healthcheck, czy też endpointy &lt;a href=&#34;https://golang.org/pkg/net/http/pprof/&#34;&gt;pprof&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&#34;weryfikacja:344187460f15e6ef8677e80bc40cccdc&#34;&gt;Weryfikacja&lt;/h2&gt;

&lt;p&gt;Aby sprawdzić, czy aplikacja zwraca poprawny wynik, posłużymy się aplikacją powłoki systemowej &lt;code&gt;curl&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ curl http://localhost:8080
It works!
$ curl -s localhost:8081/metrics | grep &#39;acme_your_app_http_requests_total{code=&amp;quot;200&amp;quot;,method=&amp;quot;get&amp;quot;}&#39;
acme_your_app_http_requests_total{code=&amp;quot;200&amp;quot;,method=&amp;quot;get&amp;quot;} 1
$ curl http://localhost:8080
It works!
$ curl -s localhost:8081/metrics | grep &#39;acme_your_app_http_requests_total{code=&amp;quot;200&amp;quot;,method=&amp;quot;get&amp;quot;}&#39;
acme_your_app_http_requests_total{code=&amp;quot;200&amp;quot;,method=&amp;quot;get&amp;quot;} 2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Zwracana wartość odpowiada ilości wysłanych żądań.
Monitoring działa bez zarzutu.&lt;/p&gt;

&lt;h2 id=&#34;podsumowanie:344187460f15e6ef8677e80bc40cccdc&#34;&gt;Podsumowanie&lt;/h2&gt;

&lt;p&gt;Aby utrzymać przejrzystość, przykłady nie zawierają wszystkich wspieranych metryk.
Podczas ich implementacji warto zapoznać się z dokumentacją dekoratorów.
Znajdują się tam informacje o wspieranych etykietach.&lt;/p&gt;

&lt;p&gt;Pełny kod źródłowy aplikacji można znaleźć &lt;a href=&#34;https://github.com/piotrkowalczuk/blog/tree/master/examples/prometheus-monitorowanie-serwera-http&#34;&gt;tutaj&lt;/a&gt;.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>W Poszukiwaniu Pracy</title>
      <link>https://piotrkowalczuk.github.io/2017/10/21/w-poszukiwaniu-pracy/</link>
      <pubDate>Sat, 21 Oct 2017 19:56:18 +0200</pubDate>
      
      <guid>https://piotrkowalczuk.github.io/2017/10/21/w-poszukiwaniu-pracy/</guid>
      <description>

&lt;h2 id=&#34;wstęp:1ee101fad5fbad352ad8ecdf4216a0b4&#34;&gt;Wstęp&lt;/h2&gt;

&lt;p&gt;Pierwsza stabilna wersja języka została wydana w marcu 2012 roku.
Od tamtego czasu mineło już ponad 5 lat.&lt;/p&gt;

&lt;p&gt;W tym czasie w rankingu &lt;a href=&#34;https://www.tiobe.com/tiobe-index/&#34;&gt;TIOBE&lt;/a&gt; język Go zanotował wzrost z 0.086% do 1.357% i plasuje się na pozycji 20.
Mogłoby się to wydawać niewiele, ale jak porównamy to do Javascript&amp;rsquo;u posiadającego obecnie 3% udziału w rynku i będącego na pozycji 6, perspektywa trochę się zmienia.&lt;/p&gt;

&lt;p&gt;Język zajmuję też 9 miejsce pod względem ilości otwartych pull requestów na &lt;a href=&#34;https://octoverse.github.com&#34;&gt;githubie&lt;/a&gt;, posiadając 285 tysięcy kontrybucji.
Dla porównania - Java, znajdująca się na miejscu drugim, posiada ich 986 tysięcy.&lt;/p&gt;

&lt;p&gt;Szacuje się, że na tą chwilę na świecie jest przynajmniej &lt;a href=&#34;https://research.swtch.com/gophercount&#34;&gt;500 tysięcy&lt;/a&gt; developerów Go.
Język otrzymał wsparcie większości edytorów oraz środowisk deweloperskich.
Na etapie Early Access jest &lt;a href=&#34;https://www.jetbrains.com/go/&#34;&gt;komercyjne IDE&lt;/a&gt; od Jetbrains.
Golang jest także preinstalowany w wielu dystrybucjach linuxa.&lt;/p&gt;

&lt;p&gt;Dlaczego o tym wszystkim piszę?
Odnoszę wrażenie, że pomimo tych wszystkich lat &lt;strong&gt;Golang&lt;/strong&gt; jest postrzegany jako coś egzotycznego i niszowego.
Przekłada się to bezpośrednio na podejscie kandydatów do procesu rekrutacji -
świadomość kandydata stoi w miejscu, a oczekiwania coraz bardziej doświadczonych zespołów rosną.&lt;/p&gt;

&lt;p&gt;Tym wpisem chciałbym wpłynąć na świadomość programistów w zakresie wymagań jakie są przed nimi stawiane. Lista poniżej jest moim &lt;strong&gt;subiektywnym&lt;/strong&gt; zestawieniem zagadnień, których znajomość w moich oczach pozytywnie wpływa na ocene kandydata.&lt;/p&gt;

&lt;h2 id=&#34;filozofia:1ee101fad5fbad352ad8ecdf4216a0b4&#34;&gt;Filozofia&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Golang&lt;/strong&gt; nie bez powodu uchodzi za język prosty do nauki.
Jego składnia jest prosta, liczba słów kluczowych niewielka, a biblioteka standardowa kompletna.&lt;/p&gt;

&lt;p&gt;W mojej ocenie jest to także jezyk (co zaskakujące) znacznie trudniejszy do opanowania niż by się mogło wydawać.&lt;/p&gt;

&lt;p&gt;Trywialnym jest napisanie bylejakiego kodu.
Trochę trudniejsze ale ciągle łatwe jest napisanie kodu przekombinowanego, z masą niepotrzebnej abstrakcji i komponentów.
Napisanie kodu, który jest genialny w swojej prostocie jest naprawde trudne.
A o prostotę przecież tutaj chodzi.&lt;/p&gt;

&lt;p&gt;Z moich obserwacji wynika, że czas potrzebny programistom na oduczenie się nawyków przyniesionych z wcześniejszych technologi jest nieakceptowalnie długi.
Nie każdy także musi podzielać wizję twórców Go, a to co przyciągneło go do języka to obietnica wydajności i wsparcia równoległego przetwarzania.
Co do zasady sądze że powinno odrzucać się kandydatów, którzy nie podzielają filozofii &lt;strong&gt;Go&lt;/strong&gt;.
Jest to zwyczajnie zbyt kosztowne i niebezpieczne dla kultury wytworzeonej w zespole.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.youtube.com/watch?v=rFejpH_tAHM&#34;&gt;Simplicity is Complicated&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://go-proverbs.github.io&#34;&gt;Proverbs&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;narzędzia:1ee101fad5fbad352ad8ecdf4216a0b4&#34;&gt;Narzędzia&lt;/h2&gt;

&lt;p&gt;Jednym z największych atutów &lt;strong&gt;Go&lt;/strong&gt; jest jego środowisko developerskie.
Poza językiem instalator instaluje również szereg narzędzi, powiedziałbym niezbędnych w codziennej pracy takich jak &lt;code&gt;cover&lt;/code&gt;, &lt;code&gt;fmt&lt;/code&gt;, &lt;code&gt;vet&lt;/code&gt;, &lt;code&gt;trace&lt;/code&gt; czy &lt;code&gt;pprof&lt;/code&gt;.
Znajomość tych narzędzi może być przydatna w trakcie rozmowy kwalifikacyjnej podczas sesji pair-programing, kiedy developer poprosi was o optymalizację albo naprawienie danej aplikacji.&lt;/p&gt;

&lt;p&gt;Ponadto, przydać się może doświadczenie z bardziej zaawansowanymi opcjami kompilacji.
Dla przykładu kiedy chcemy przeprowadzić &lt;a href=&#34;https://en.wikipedia.org/wiki/Escape_analysis&#34;&gt;Escape Analysis&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&#34;współdzielenie-danych-i-synchronizacja:1ee101fad5fbad352ad8ecdf4216a0b4&#34;&gt;Współdzielenie danych i synchronizacja&lt;/h2&gt;

&lt;p&gt;Kanały są jednym z najbardziej rozpoznawalnych aspektów &lt;strong&gt;Go&lt;/strong&gt;.
Ich poprawne stosowanie przysparza kandydatom jednak wiele problemów.
To zły znak.
Przejawia się to najczęściej zbyt dużą ich ilością, dodatkowo niepotrzebnie użytą strukturą &lt;code&gt;sync.WaitGroup&lt;/code&gt; czy poprostu stosowaniem ich tam, gdzie jest to zbędne.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Share memory by communicating; don&amp;rsquo;t communicate by sharing memory&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Potencjalny kandydat musi rozumieć kiedy stosować kanały, &lt;a href=&#34;https://pl.wikipedia.org/wiki/Problem_wzajemnego_wykluczania&#34;&gt;mutex&lt;/a&gt; czy też może sprzętową synchronizację dostępną w paczce &lt;a href=&#34;https://golang.org/pkg/sync/atomic/&#34;&gt;sync/atomic&lt;/a&gt;.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://greenteapress.com/wp/semaphores/&#34;&gt;The Little Book of Semaphores&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://sigops.org/sosp/sosp13/papers/p33-david.pdf&#34;&gt;Everything You Always Wanted to Know About Synchronization but Were Afraid to Ask&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.golang.org/pipelines&#34;&gt;Go Concurrency Patterns: Pipelines and cancellation&lt;/a&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;przerwania:1ee101fad5fbad352ad8ecdf4216a0b4&#34;&gt;Przerwania&lt;/h2&gt;

&lt;p&gt;We wszelkiego rodzaju aplikacjach webowych czy też systemach rozproszonych, możliwość przerwania przetwarzania żądania jest na wagę złota.
Taki mechanizm pozwala kontrolować zużycie zasobów (ich zwalnianie) oraz przestrzec się przed katastrofalnym w skutkach efektem domina.&lt;/p&gt;

&lt;p&gt;Znajomość paczki &lt;a href=&#34;https://golang.org/pkg/context&#34;&gt;context&lt;/a&gt; jest tutaj kluczowa.
Za jej pomocą jesteśmy w stanie anulować żądania oraz procesy, a także określać górną granice czasu, w którym nasza logika ma zostać wykonana.&lt;/p&gt;

&lt;p&gt;Temat zdecydowanie zasługuje na osobny wpis.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.golang.org/context&#34;&gt;Go Concurrency Patterns: Context&lt;/a&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;whitebox-monitoring-tracing:1ee101fad5fbad352ad8ecdf4216a0b4&#34;&gt;Whitebox Monitoring/Tracing&lt;/h2&gt;

&lt;p&gt;Ostatecznie nasz kod ląduje na produkcji.
Rolą dewelopera jest udostępnienie metryk, które pomogą określić wydajność aplikacji oraz zweryfikować jej poprawne działanie.&lt;/p&gt;

&lt;p&gt;Do monitorowania najczęstszym wyborem, w przypadku zespołów, czysto Golangowych jest &lt;a href=&#34;https://prometheus.io&#34;&gt;Prometheus&lt;/a&gt;.
Najpewniej żadne zadanie testowe nie będzie wymagać jego zastosowania, ale znajomość zagadnienia jest jak najbardziej na plus.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Tracing_(software)&#34;&gt;Tracing&lt;/a&gt; może zostać zaimplementowany na wiele sposobów.
Na początek, znajomość paczki &lt;a href=&#34;https://godoc.org/golang.org/x/net/trace&#34;&gt;x/net/trace&lt;/a&gt; powinna wystarczyć.&lt;/p&gt;

&lt;h2 id=&#34;podsumowanie:1ee101fad5fbad352ad8ecdf4216a0b4&#34;&gt;Podsumowanie&lt;/h2&gt;

&lt;p&gt;Mimo iż &lt;strong&gt;Golang&lt;/strong&gt; jest stosowany przewarznie w zastosowaniach serwerowych/cloudowych, nie musi to być zasadą.&lt;/p&gt;

&lt;p&gt;Wiele tematów takich jak testowanie, benchmnarking czy stosowanie paczki &lt;code&gt;http&lt;/code&gt; umyślnie zignorowałem.
Skupiłem się jedynie na aspektach, które najczęsciej są pomijane przez kandydatów, których miałem przyjemność ewaluować.&lt;/p&gt;

&lt;p&gt;Mam nadzieję, że powyższy tekst pomoże komuś w znalezieniu upragnionej pracy.
Wszystkim przyszłym &lt;a href=&#34;https://blog.golang.org/gopher&#34;&gt;gopherom&lt;/a&gt; życzę powodzenia.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Kolejka Priorytetowa</title>
      <link>https://piotrkowalczuk.github.io/2016/07/10/kolejka-priorytetowa/</link>
      <pubDate>Sun, 10 Jul 2016 20:12:00 +0200</pubDate>
      
      <guid>https://piotrkowalczuk.github.io/2016/07/10/kolejka-priorytetowa/</guid>
      <description>

&lt;h2 id=&#34;wstęp:042cb00d946fbfbaf0b1b50f0ee94629&#34;&gt;Wstęp&lt;/h2&gt;

&lt;p&gt;Kolejka priorytetowa to abstrakcyjna struktura danych gdzie elementy są uszeregowane według danej wielkości.
Kolejka ta nie jest kolejką typu FIFO czy też LIFO.
Ponieważ jest to &lt;a href=&#34;https://pl.wikipedia.org/wiki/Abstrakcyjny_typ_danych&#34;&gt;ADT&lt;/a&gt; może być ona zaimplementowana na wielę sposobów:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Kopiec binarny&lt;/li&gt;
&lt;li&gt;Kopiec dwumianowy&lt;/li&gt;
&lt;li&gt;Tablica&lt;/li&gt;
&lt;li&gt;Lista&lt;/li&gt;
&lt;li&gt;Rownoważone BST&lt;/li&gt;
&lt;li&gt;Kopiec Fibonacciego&lt;/li&gt;
&lt;li&gt;Kolejka Brodala&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;zagadnienie:042cb00d946fbfbaf0b1b50f0ee94629&#34;&gt;Zagadnienie&lt;/h2&gt;

&lt;p&gt;Aby nadać problemowi bardziej intuicyjny charakter spróbujmy zastosować go w praktyce.
Naszym zadaniem będzie utworzenie kolejki poleceń. Zadania mogą być dodawane w dowolnej kolejności.
Każde polecenie powinno być opisane przez:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;id&lt;/code&gt; - identyfikator&lt;/li&gt;
&lt;li&gt;&lt;code&gt;index&lt;/code&gt; - miejsce w kolejce&lt;/li&gt;
&lt;li&gt;&lt;code&gt;name&lt;/code&gt; - nazwa&lt;/li&gt;
&lt;li&gt;&lt;code&gt;timestamp&lt;/code&gt; - data do kiedy zadanie powinno zostać wykonane&lt;/li&gt;
&lt;li&gt;&lt;code&gt;epsilon&lt;/code&gt; - czas po wyznaczonej dacie wykonania po upłynięciu którego zadanie powinno zostać porzucone&lt;/li&gt;
&lt;li&gt;&lt;code&gt;command&lt;/code&gt; - komenda uruchamiająca skrypt/program&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;propozycja-rozwiązania:042cb00d946fbfbaf0b1b50f0ee94629&#34;&gt;Propozycja rozwiązania&lt;/h3&gt;

&lt;p&gt;Biblioteka standardowa Go jest naprawdę bogata.
Nie zabrakło także implementacji stosu (binarnego).
Paczka &lt;a href=&#34;https://golang.org/pkg/container/heap/&#34;&gt;heap&lt;/a&gt;, bo o niej tutaj mowa dostarcza nam taki oto interface:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type Interface interface {
	sort.Interface
	Push(x interface{})
	Pop() interface{}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Który jeżeli zaimplementowany poprawnie może być wykorzystany przy użyciu szeregu funkcji:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://golang.org/pkg/container/heap/#Init&#34;&gt;heap.Init&lt;/a&gt; - inicjalizacja stosu, &lt;code&gt;O(n)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://golang.org/pkg/container/heap/#Push&#34;&gt;heap.Push&lt;/a&gt; - dodanie elementu, &lt;code&gt;O(log(n))&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://golang.org/pkg/container/heap/#Pop&#34;&gt;heap.Pop&lt;/a&gt; - usuniecie elementu minimalnego, &lt;code&gt;O(log(n))&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://golang.org/pkg/container/heap/#Remove&#34;&gt;heap.Remove&lt;/a&gt; - usuniecie elementy pod podanym indexem, &lt;code&gt;O(log(n))&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://golang.org/pkg/container/heap/#Fix&#34;&gt;heap.Fix&lt;/a&gt; - &amp;ldquo;naprawienie&amp;rdquo; stosu po np zmianie wartosci jednego z elementow, &lt;code&gt;O(log(n))&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;implementacja:042cb00d946fbfbaf0b1b50f0ee94629&#34;&gt;Implementacja&lt;/h3&gt;

&lt;p&gt;Raz jeszcze skorzystamy z dobrodziejstw biblioteki standardowej.
Znaleźć w niej możemy paczkę &lt;a href=&#34;https://golang.org/pkg/os/exec/&#34;&gt;exec&lt;/a&gt; w której to znajduje się struktura &lt;a href=&#34;https://golang.org/pkg/os/exec/#Cmd&#34;&gt;exec.Cmd&lt;/a&gt;.
Struktura reporezentująca pojedyńcze polecenie do wykonania mogłaby wyglądać następująco:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type Job struct {
	ID int64
	Index int64
	Name string
	Timestamp time.Time
	Epsilon time.Duration
	Command *exec.Cmd
}

type Jobs []*Job
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Kolekcja takich struktur musi implementować wcześniej wymieniony &lt;a href=&#34;https://golang.org/pkg/container/heap/#Interface&#34;&gt;Interface&lt;/a&gt;.
A więc po kolei:&lt;/p&gt;

&lt;h4 id=&#34;len:042cb00d946fbfbaf0b1b50f0ee94629&#34;&gt;Len&lt;/h4&gt;

&lt;p&gt;Jak sama nazwa wskazuje sprawdza długość kolekcji.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Len implements sort Interface.
func (j Jobs) Len() int {
	return len(j)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;less:042cb00d946fbfbaf0b1b50f0ee94629&#34;&gt;Less&lt;/h4&gt;

&lt;p&gt;Metoda ta nie tylko sprawdza który deadline nastąpi jako pierwszy,
ale w wypadku gdy są równe, porównuje także wartość &lt;code&gt;Epsilon&lt;/code&gt;.
Jest to jedynie przykładowa implementacja.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Less implements sort Interface.
func (j Jobs) Less(n, m int) bool {
	if j[n].Timestamp.Equal(j[m].Timestamp) {
		return j[n].Epsilon &amp;lt; j[m].Epsilon
	}
	return j[n].Timestamp.Before(j[m].Timestamp)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;swap:042cb00d946fbfbaf0b1b50f0ee94629&#34;&gt;Swap&lt;/h4&gt;

&lt;p&gt;Nic innego jak zamiana elementów pod wskazanymi indeksami.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Swap implements sort Interface.
func (j Jobs) Swap(n, m int) {
	j[n], j[m] = j[m], j[n]
	j[n].Index = int64(n)
	j[m].Index = int64(m)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;push:042cb00d946fbfbaf0b1b50f0ee94629&#34;&gt;Push&lt;/h4&gt;

&lt;p&gt;Przez push rozumiemy dodanie na koniec kolekcji nowego elementu i ustawienie jego indeksu na &lt;code&gt;n&lt;/code&gt;.
Funkcja &lt;a href=&#34;https://golang.org/pkg/container/heap/#Push&#34;&gt;heap.Push&lt;/a&gt; użyje tej metody na początku, a następnie będzie przesuwać element do góry tak długo jak to tylko możliwe, aż osiągnie właściwy dla siebie index wynikający z warunku zawartego w metodzie &lt;code&gt;Less&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Push implements heap Interface.
func (j *Jobs) Push(x interface{}) {
	n := len(*j)
	item := x.(*Job)
	item.Index = int64(n)
	*j = append(*j, item)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;pop:042cb00d946fbfbaf0b1b50f0ee94629&#34;&gt;Pop&lt;/h4&gt;

&lt;p&gt;Usuniecie zadania z kolejki odbywa się przez utworzenie nowego &lt;a href=&#34;https://blog.golang.org/go-slices-usage-and-internals&#34;&gt;slice&amp;rsquo;a&lt;/a&gt; z pominięciem ostatniego elementu.
Dla jasności ustawiamy także &lt;code&gt;Index&lt;/code&gt; usuniętego elementu na &lt;code&gt;-1&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Pop implements heap Interface.
func (j *Jobs) Pop() interface{} {
	old := *j
	n := len(old)
	item := old[n-1]
	item.Index = -1
	*j = old[0 : n-1]
	return item
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;efekt-końcowy:042cb00d946fbfbaf0b1b50f0ee94629&#34;&gt;Efekt końcowy&lt;/h4&gt;

&lt;p&gt;Całość działa tak jak przewiduje to koncepcja kolejki priorytetowej.
&lt;a href=&#34;https://blog.golang.org/examples&#34;&gt;Testowy przykład&lt;/a&gt; to potwierdza.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func ExampleJobs() {
	jobs := make(Jobs, 0, 3)
	zero := time.Now()
	heap.Init(&amp;amp;jobs)
	heap.Push(&amp;amp;jobs, &amp;amp;Job{
		ID:        1,
		Name:      &amp;quot;first&amp;quot;,
		Timestamp: zero.Add(10 * time.Hour),
		Epsilon:   5 * time.Minute,
		Command:   exec.Command(&amp;quot;ls&amp;quot;, &amp;quot;-lha&amp;quot;),
	})
	heap.Push(&amp;amp;jobs, &amp;amp;Job{
		ID:        1,
		Name:      &amp;quot;second&amp;quot;,
		Timestamp: zero.Add(10 * time.Hour),
		Epsilon:   4 * time.Minute,
		Command:   exec.Command(&amp;quot;pwd&amp;quot;),
	})
	heap.Push(&amp;amp;jobs, &amp;amp;Job{
		ID:        1,
		Name:      &amp;quot;third&amp;quot;,
		Timestamp: zero.Add(5 * time.Hour),
		Epsilon:   4 * time.Minute,
		Command:   exec.Command(&amp;quot;ps&amp;quot;, &amp;quot;aux&amp;quot;),
	})
	fmt.Println(jobs.Len())

	j1 := heap.Pop(&amp;amp;jobs).(*Job)
	j2 := heap.Pop(&amp;amp;jobs).(*Job)
	j3 := heap.Pop(&amp;amp;jobs).(*Job)

	fmt.Println(j1.Name)
	fmt.Println(j2.Name)
	fmt.Println(j3.Name)
	fmt.Println(jobs.Len())

	// Output:
	// 3
	// third
	// second
	// first
	// 0
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;wnioski:042cb00d946fbfbaf0b1b50f0ee94629&#34;&gt;Wnioski&lt;/h2&gt;

&lt;p&gt;Kolejka priorytetowa to bardzo ważna struktura danych szczególnie w przypadku wszelkiego rodzaju aplikacji serwerowych.
Przed przystąpieniem do rozwiazania problemu warto przyjrzeć się &lt;a href=&#34;https://golang.org/pkg/&#34;&gt;bibliotece standardowej&lt;/a&gt;,
może zawierać ona przydatne interfacy/implementacje czy także &lt;a href=&#34;https://golang.org/pkg/container/heap/#example__priorityQueue&#34;&gt;przykłady&lt;/a&gt;:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://golang.org/pkg/container/heap&#34;&gt;container/heap&lt;/a&gt; - implementacja stosu&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://golang.org/pkg/container/list&#34;&gt;container/list&lt;/a&gt; - implementacja podwujnie łączonej listy&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://golang.org/pkg/container/ring&#34;&gt;container/ring&lt;/a&gt; - operacje na listach cyklicznych&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
  </channel>
</rss>