<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Prometheus on Piotr Kowalczuk Blog</title>
    <link>https://piotrkowalczuk.github.io/tags/prometheus/</link>
    <description>Recent content in Prometheus on Piotr Kowalczuk Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>pl</language>
    <copyright>Piotr Kowalczuk</copyright>
    <lastBuildDate>Tue, 14 Nov 2017 00:12:21 +0100</lastBuildDate>
    <atom:link href="https://piotrkowalczuk.github.io/tags/prometheus/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Prometheus</title>
      <link>https://piotrkowalczuk.github.io/2017/11/14/prometheus-monitorowanie-serwera-http/</link>
      <pubDate>Tue, 14 Nov 2017 00:12:21 +0100</pubDate>
      
      <guid>https://piotrkowalczuk.github.io/2017/11/14/prometheus-monitorowanie-serwera-http/</guid>
      <description>

&lt;h2 id=&#34;czym-jest-prometheus:344187460f15e6ef8677e80bc40cccdc&#34;&gt;Czym jest Prometheus?&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://prometheus.io&#34;&gt;Prometheus&lt;/a&gt; jest to ekosystem do monitorowania napisany przez programistów z &lt;a href=&#34;https://soundcloud.com&#34;&gt;SoundCloud&lt;/a&gt;.
Jak możecie się przekonać przeglądając oficjalne konto na &lt;a href=&#34;https://github.com/prometheus&#34;&gt;githubie&lt;/a&gt;, większość środowiska jest napisana w &lt;a href=&#34;http://golang.org&#34;&gt;Go&lt;/a&gt;.
Od 2016 roku projekt jest też częścią &lt;a href=&#34;https://www.cncf.io&#34;&gt;Cloud Native Computing Foundation&lt;/a&gt; obok takich rozwiązań jak &lt;a href=&#34;https://kubernetes.io&#34;&gt;kubernetes&lt;/a&gt;, &lt;a href=&#34;http://grpc.io&#34;&gt;gRPC&lt;/a&gt; czy &lt;a href=&#34;http://opentracing.io&#34;&gt;OpenTracing&lt;/a&gt;.
Daje nam to pewność, że projekt będzie rozwijany przez długie lata, będzie ewoluował razem z resztą środowiska, a także wsparcie dla &lt;strong&gt;Go&lt;/strong&gt; będzie stało na najwyższym poziomie.&lt;/p&gt;

&lt;p&gt;Skupię się tutaj na ostatniej wersji, oznaczonej tagiem &lt;code&gt;v0.8.0&lt;/code&gt;.
W tej wersji wiele funkcji zostało oznaczonych jako &lt;code&gt;DEPRECATED&lt;/code&gt; i zostaną one przeze mnie pominięte.
Zalecana wersja Go to 1.9+.&lt;/p&gt;

&lt;h2 id=&#34;biblioteka:344187460f15e6ef8677e80bc40cccdc&#34;&gt;Biblioteka&lt;/h2&gt;

&lt;p&gt;Zasadniczo &lt;strong&gt;Prometheus&lt;/strong&gt; jako serwer centralny musi być świadomy istnienia aplikacji która jest monitorowana.
Tylko wtedy jest on w stanie pobrać metryki ze wskazanego endpointu.
Z pomocą przychodzi nam biblioteka &lt;a href=&#34;https://godoc.org/github.com/prometheus/client_golang/prometheus/promhttp&#34;&gt;promhttp&lt;/a&gt;, która jest częścią składową oficjalnej &lt;a href=&#34;https://github.com/prometheus/client_golang/tree/master/prometheus&#34;&gt;paczki&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://godoc.org/github.com/prometheus/client_golang/prometheus/promhttp#HandlerFor&#34;&gt;promhttp.HandlerFor&lt;/a&gt; pozwala utworzyć endpoint dla danego &lt;a href=&#34;https://godoc.org/github.com/prometheus/client_golang/prometheus#Gatherer&#34;&gt;prometheus.Gatherer&amp;rsquo;a&lt;/a&gt;.
Interfejs ten jest na przykład implementowany przez &lt;a href=&#34;https://godoc.org/github.com/prometheus/client_golang/prometheus#pkg-variables&#34;&gt;prometheus.DefaultRegisterer&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Ponadto biblioteka ta zawiera garść dekoratorów które, pozwolą nam zbierać informacje na temat naszej aplikacji:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://godoc.org/github.com/prometheus/client_golang/prometheus/promhttp#InstrumentHandlerCounter&#34;&gt;promhttp.InstrumentHandlerCounter&lt;/a&gt; - całkowita liczba przetworzonych żądań&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://godoc.org/github.com/prometheus/client_golang/prometheus/promhttp#InstrumentHandlerDuration&#34;&gt;promhttp.InstrumentHandlerDuration&lt;/a&gt; - czas trwania żądania&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://godoc.org/github.com/prometheus/client_golang/prometheus/promhttp#InstrumentHandlerTimeToWriteHeader&#34;&gt;promhttp.InstrumentHandlerTimeToWriteHeader&lt;/a&gt; - podobnie jak poprzedni tylko do czasu wysłania nagłówków&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://godoc.org/github.com/prometheus/client_golang/prometheus/promhttp#InstrumentHandlerInFlight&#34;&gt;promhttp.InstrumentHandlerInFlight&lt;/a&gt; - liczba obecnie przetwarzanych żądań (w trakcie)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://godoc.org/github.com/prometheus/client_golang/prometheus/promhttp#InstrumentHandlerRequestSize&#34;&gt;promhttp.InstrumentHandlerRequestSize&lt;/a&gt; - wielkość żądania&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;implementacja:344187460f15e6ef8677e80bc40cccdc&#34;&gt;Implementacja&lt;/h2&gt;

&lt;p&gt;Jak widać, żeby zacząć nie trzeba się wiele napracować. Większość potrzebnych nam składników jest już dostępna.
Brakujący element to &lt;a href=&#34;https://godoc.org/github.com/prometheus/client_golang/prometheus#Collector&#34;&gt;kolektory&lt;/a&gt; które musimy zainicjować własnoręcznie.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;duration := prometheus.NewHistogramVec(
    prometheus.HistogramOpts{
        Namespace: &amp;quot;acme&amp;quot;,
        Subsystem: &amp;quot;your_app&amp;quot;,
        Name:      &amp;quot;http_durations_histogram_seconds&amp;quot;,
        Help:      &amp;quot;Request time duration.&amp;quot;,
    },
    []string{&amp;quot;code&amp;quot;, &amp;quot;method&amp;quot;},
)
requests := prometheus.NewCounterVec(
    prometheus.CounterOpts{
        Namespace: &amp;quot;acme&amp;quot;,
        Subsystem: &amp;quot;your_app&amp;quot;,
        Name:      &amp;quot;http_requests_total&amp;quot;,
        Help:      &amp;quot;Total number of requests received.&amp;quot;,
    },
    []string{&amp;quot;code&amp;quot;, &amp;quot;method&amp;quot;},
)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Oba one muszą zostać zarejestrowane, a następnie przekazane jako argument do wyżej wymienionych dekoratorów.
Możemy trochę usprawnić ten proces poprzez wprowadzenie dodatkowej struktury.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type decorator struct {
	duration *prometheus.HistogramVec
	requests *prometheus.CounterVec
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Aby spełniać swoje zadanie, struktóra ta powinna implementować interfejs &lt;a href=&#34;https://godoc.org/github.com/prometheus/client_golang/prometheus#Collector&#34;&gt;prometheus.Collector&lt;/a&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Describe implements prometheus Collector interface.
func (d *decorator) Describe(in chan&amp;lt;- *prometheus.Desc) {
	d.duration.Describe(in)
	d.requests.Describe(in)
}

// Collect implements prometheus Collector interface.
func (d *decorator) Collect(in chan&amp;lt;- prometheus.Metric) {
	d.duration.Collect(in)
	d.requests.Collect(in)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Dodatkowo, możemy zredukować duplikację kodu implementując dodatkową metodę.
Jej zadaniem będzie dekorowanie danego handlera szeregiem funkcji.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func (d *decorator) instrument(handler http.Handler) http.Handler {
	return promhttp.InstrumentHandlerDuration(
		d.duration,
		promhttp.InstrumentHandlerCounter(
			d.requests,
			handler,
		),
	)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Naszym ostatnim krokiem będzie połączenie wszystkiego ze sobą i udostępnienie metryk.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func main() {
    dec := &amp;amp;decorator{
        // inicjalizacja
    }

    prometheus.DefaultRegisterer.Register(dec)

    go func() {
        dbg := http.NewServeMux()
        dbg.Handle(&amp;quot;/metrics&amp;quot;, promhttp.HandlerFor(
            prometheus.DefaultGatherer,
            promhttp.HandlerOpts{},
        ))
        http.ListenAndServe(&amp;quot;0.0.0.0:8081&amp;quot;, dbg)
    }()

    app := http.NewServeMux()
    app.Handle(&amp;quot;/&amp;quot;, dec.instrument(&amp;amp;handler{}))
    http.ListenAndServe(&amp;quot;0.0.0.0:8080&amp;quot;, app)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Aplikacja przez nas napisana będzie nasłuchiwać na dwóch portach.
Pierwszy &lt;code&gt;8080&lt;/code&gt;, zarezerowany dla aplikacji właściwej.
Drugi &lt;code&gt;8081&lt;/code&gt;, na którym prometheus będzie miał dostęp do metryk.
Chciałbym zwrócić uwagę, że router został w drugim przypadku zastosowany nie bez powodu.
Pozwoli on w przyszłości udostępnić na tym samym porcie healthcheck, czy też endpointy &lt;a href=&#34;https://golang.org/pkg/net/http/pprof/&#34;&gt;pprof&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&#34;weryfikacja:344187460f15e6ef8677e80bc40cccdc&#34;&gt;Weryfikacja&lt;/h2&gt;

&lt;p&gt;Aby sprawdzić, czy aplikacja zwraca poprawny wynik, posłużymy się aplikacją powłoki systemowej &lt;code&gt;curl&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ curl http://localhost:8080
It works!
$ curl -s localhost:8081/metrics | grep &#39;acme_your_app_http_requests_total{code=&amp;quot;200&amp;quot;,method=&amp;quot;get&amp;quot;}&#39;
acme_your_app_http_requests_total{code=&amp;quot;200&amp;quot;,method=&amp;quot;get&amp;quot;} 1
$ curl http://localhost:8080
It works!
$ curl -s localhost:8081/metrics | grep &#39;acme_your_app_http_requests_total{code=&amp;quot;200&amp;quot;,method=&amp;quot;get&amp;quot;}&#39;
acme_your_app_http_requests_total{code=&amp;quot;200&amp;quot;,method=&amp;quot;get&amp;quot;} 2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Zwracana wartość odpowiada ilości wysłanych żądań.
Monitoring działa bez zarzutu.&lt;/p&gt;

&lt;h2 id=&#34;podsumowanie:344187460f15e6ef8677e80bc40cccdc&#34;&gt;Podsumowanie&lt;/h2&gt;

&lt;p&gt;Aby utrzymać przejrzystość, przykłady nie zawierają wszystkich wspieranych metryk.
Podczas ich implementacji warto zapoznać się z dokumentacją dekoratorów.
Znajdują się tam informacje o wspieranych etykietach.&lt;/p&gt;

&lt;p&gt;Pełny kod źródłowy aplikacji można znaleźć &lt;a href=&#34;https://github.com/piotrkowalczuk/blog/tree/master/examples/prometheus-monitorowanie-serwera-http&#34;&gt;tutaj&lt;/a&gt;.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>